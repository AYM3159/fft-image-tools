<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FFT Image Decoder</title>
  <style>
    body { font-family: sans-serif; padding: 10px; max-width: 95%; margin: auto; }
	canvas { border: 1px solid #ccc; display: block; margin: 1em 0; }
    label { display: block; margin: 1em 0 0.5em; }
    input, button { font-size: 1em; }
    .container { display: flex; gap: 20px; margin: 20px 0; }
	button {
		padding: 5px 10px;
		margin: 5px;
		font-size: 12px;
		cursor: pointer;
	}
  </style>
</head>
<body>
  <h1>FFT Image Decoder</h1>

  <label>Magnitude Pack 1: <input type="file" id="mag1"></label>
  <label>Magnitude Pack 2: <input type="file" id="mag2"></label>
  <label>Phase Pack: <input type="file" id="phasePack"></label>
  <label>Max Magnitude: <input type="number" id="maxMag" step="any"></label>
  <div class="container">
	<button id="runBtn" disabled>Decode</button>
	<button id="dwlBtn" disabled>Download</button>
  </div>
  <div class="container">
	<canvas id="out"></canvas>
  </div>

  <script>
  function fft(re,im){
    const N=re.length;
    if(N<=1)return;
    const H=N>>1, rE=new Float64Array(H),iE=new Float64Array(H),
          rO=new Float64Array(H),iO=new Float64Array(H);
    for(let k=0;k<H;k++){
      rE[k]=re[2*k]; iE[k]=im[2*k];
      rO[k]=re[2*k+1]; iO[k]=im[2*k+1];
    }
    fft(rE,iE); fft(rO,iO);
    for(let k=0;k<H;k++){
      const ang=-2*Math.PI*k/N, c=Math.cos(ang), s=Math.sin(ang),
            tr=c*rO[k]-s*iO[k], ti=s*rO[k]+c*iO[k];
      re[k]=rE[k]+tr;    im[k]=iE[k]+ti;
      re[k+H]=rE[k]-tr;  im[k+H]=iE[k]-ti;
    }
  }
  function ifft(re,im){
    for(let i=0;i<im.length;i++) im[i]=-im[i];
    fft(re,im);
    const N=re.length;
    for(let i=0;i<N;i++){
      re[i]/=N; im[i]=-im[i]/N;
    }
  }
  function ifft2D(re,im,w,h){
    const r1=new Float64Array(w),i1=new Float64Array(w);
    for(let y=0;y<h;y++){
      const off=y*w;
      for(let x=0;x<w;x++){ r1[x]=re[off+x]; i1[x]=im[off+x]; }
      ifft(r1,i1);
      for(let x=0;x<w;x++){ re[off+x]=r1[x]; im[off+x]=i1[x]; }
    }
    const r2=new Float64Array(h),i2=new Float64Array(h);
    for(let x=0;x<w;x++){
      for(let y=0;y<h;y++){
        const idx=y*w+x;
        r2[y]=re[idx]; i2[y]=im[idx];
      }
      ifft(r2,i2);
      for(let y=0;y<h;y++){
        re[y*w+x]=r2[y]; im[y*w+x]=i2[y];
      }
    }
  }
  function ifftshift2D(arr, width, height) {
  const unshifted = new Array(height);
  for (let y = 0; y < height; y++) {
    unshifted[y] = new Array(width);
    for (let x = 0; x < width; x++) {
      const dstX = (x + width / 2) % width;
      const dstY = (y + height / 2) % height;
      unshifted[y][x] = arr[dstY][dstX];
    }
  }
  return unshifted;
}
  // DOM
  const mag1In = document.getElementById('mag1'),
        mag2In = document.getElementById('mag2'),
        phIn   = document.getElementById('phasePack'),
        maxIn  = document.getElementById('maxMag'),
        runBtn = document.getElementById('runBtn'),
		dwlBtn = document.getElementById('dwlBtn'),
        outC   = document.getElementById('out'),
        oCtx   = outC.getContext('2d');

  let img1,img2,img3;
  [mag1In,mag2In,phIn].forEach((el,i)=>
    el.onchange=e=>{
      const f=e.target.files[0];
      if(!f)return;
      const img=new Image();
      img.onload=()=>{
        if(i===0)img1=img;
        if(i===1)img2=img;
        if(i===2)img3=img;
        check();
      };
      img.src=URL.createObjectURL(f);
    }
  );
  maxIn.oninput=check;
  function check(){
    runBtn.disabled=!(img1&&img2&&img3&&parseFloat(maxIn.value)>0);
  }

  runBtn.onclick=()=>{
    const maxM=parseFloat(maxIn.value),
          PW=img1.width, PH=img1.height;
    const W_orig = parseInt(img1.naturalWidth) || PW,
          H_orig = parseInt(img1.naturalHeight)|| PH;

    outC.width=W_orig; outC.height=H_orig;

    // draw to temp
    const c1=document.createElement('canvas'),
          c2=document.createElement('canvas'),
          c3=document.createElement('canvas');
    [c1,c2,c3].forEach(c=>{c.width=PW;c.height=PH;});
    const ctx1=c1.getContext('2d'),ctx2=c2.getContext('2d'),ctx3=c3.getContext('2d');
    ctx1.drawImage(img1,0,0);ctx2.drawImage(img2,0,0);ctx3.drawImage(img3,0,0);
    const d1=ctx1.getImageData(0,0,PW,PH).data,
          d2=ctx2.getImageData(0,0,PW,PH).data,
          d3=ctx3.getImageData(0,0,PW,PH).data;

    const N = PW*PH;
    const magR=new Float64Array(N), magG=new Float64Array(N), magB=new Float64Array(N),
          phR =new Float64Array(N), phG =new Float64Array(N), phB =new Float64Array(N);

    for(let i=0;i<N;i++){
      const hiR=d1[4*i], loR=d1[4*i+1], hiG=d1[4*i+2],
            loG=d2[4*i], hiB=d2[4*i+1], loB=d2[4*i+2],
            pR=d3[4*i], pG=d3[4*i+1], pB=d3[4*i+2];
      magR[i]=((hiR<<8)|loR)/65535*maxM;
      magG[i]=((hiG<<8)|loG)/65535*maxM;
      magB[i]=((hiB<<8)|loB)/65535*maxM;
      phR[i]=(pR/255)*2*Math.PI - Math.PI;
      phG[i]=(pG/255)*2*Math.PI - Math.PI;
      phB[i]=(pB/255)*2*Math.PI - Math.PI;
    }

    function recon(mag,ph){
      const re=new Float64Array(N), im=new Float64Array(N);
      for(let i=0;i<N;i++){
        re[i]=mag[i]*Math.cos(ph[i]);
        im[i]=mag[i]*Math.sin(ph[i]);
      }
	  const re2D = Array.from({length: PH}, (_, y) => re.slice(y * PW, (y + 1) * PW));
	  const im2D = Array.from({length: PH}, (_, y) => im.slice(y * PW, (y + 1) * PW));

	  const reUnshifted = ifftshift2D(re2D, PW, PH);
	  const imUnshifted = ifftshift2D(im2D, PW, PH);
	 
	  for (let y = 0; y < PH; y++) {
	  	for (let x = 0; x < PW; x++) {
	  		const i = y * PW + x;
	  		re[i] = reUnshifted[y][x];
	  		im[i] = imUnshifted[y][x];
	  	}
	  }
      ifft2D(re,im,PW,PH);
      return re;
    }
    const R=recon(magR,phR), G=recon(magG,phG), B=recon(magB,phB);

    // normalize
    let mn=Infinity, mx=-Infinity;
    [R,G,B].forEach(arr=>arr.forEach(v=>{mn=Math.min(mn,v);mx=Math.max(mx,v);} ));
    const rng=(mx-mn)||1;
    const outImg=oCtx.createImageData(PW,PH), od=outImg.data;
    for(let i=0;i<N;i++){
      od[4*i  ]=Math.round((R[i]-mn)/rng*255);
      od[4*i+1]=Math.round((G[i]-mn)/rng*255);
      od[4*i+2]=Math.round((B[i]-mn)/rng*255);
      od[4*i+3]=255;
    }
	dwlBtn.disabled=false;
	runBtn.disabled=true;
    // crop to original
    oCtx.putImageData(outImg,0,0,0,0,W_orig,H_orig);
  };
  	document.getElementById('dwlBtn').addEventListener('click', () => {
		const link = document.createElement('a');
		link.download = 'DecodedImage.png';
		link.href = out.toDataURL();
		link.click();
	});
  </script>
</body>
</html>
